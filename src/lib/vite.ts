import type { Plugin, ResolvedConfig } from 'vite';
import { discoverContentPaths, loadContent, filetypes } from './content.js';
import { sveltekit } from '@sveltejs/kit/vite';
import { default as Debug } from 'debug';
import path from 'node:path';

import type {
  SourceComponentContent,
  Config,
  SourcePageContent
} from './types.d.ts';
import { toAbsolutePath } from './utils.js';

const logBase = Debug('composably');
const logConfig = Debug('composably:config');
const logCache = Debug('composably:cache');
const logLoad = Debug('composably:load');
const logHMR = Debug('composably:hmr');

// --- Constants for virtual module IDs ---

// User-facing prefix (used in import statements)
const PLUGIN_PREFIX = 'composably:';

// Specific virtual module IDs (user-facing)
// e.g., import contentList from 'composably:content';
const VIRTUAL_CONTENT = `${PLUGIN_PREFIX}content`;
// e.g., import page from 'composably:content/about';
const VIRTUAL_PAGE = `${PLUGIN_PREFIX}content/`;
// e.g., import Comp from 'composably:component/[short-hash].svelte';
const VIRTUAL_COMPONENT = `${PLUGIN_PREFIX}component/`;

// Resolved IDs (internal, prefixed with null byte)
const RESOLVED_CONTENT = `\0${VIRTUAL_CONTENT}`;
const RESOLVED_PAGE = `\0${VIRTUAL_PAGE}`;

// Suffix for virtual component imports (ensure it's consistent)
const COMPONENT_SUFFIX = '.svelte';

// Empty source map for virtual components
// Not critical but it silences SvelteKit warnings about missing source files.
const VIRTUAL_SOURCEMAP = {
  version: 3,
  sources: [],
  names: [],
  mappings: ''
};

// ---------------------------------------------

export async function composablyWithSveltekit(
  config: Config
): Promise<Plugin[]> {
  const composablyPlugin = await composably(config);
  const sveltePlugins = await sveltekit();
  return [composablyPlugin, ...sveltePlugins];
}

// Cache for resolved page content promises
// Key: entryPath (e.g., 'about')
// Value: { promise: Promise<PageContent>, sourceFiles: Set<string> }
const pageCache = new Map<
  string,
  { promise: Promise<SourcePageContent>; sourceFiles: Set<string> }
>();

// Cache for virtual component data
// Key: virtual component ID (e.g., 'composably:component/MyVirtualComp')
// Value: { data: SourceComponentContent, sourceEntryPath: string }
const virtualComponentCache = new Map<
  string,
  { data: SourceComponentContent; sourceEntryPath: string }
>();

// Dependency tracking: Source file -> Content Entries
// Key: Absolute path of a source file (primary or fragment)
// Value: Set<string> of entryPaths that depend on this file
const fileToContentEntries = new Map<string, Set<string>>();

// Dependency tracking: Content Entry -> Virtual Components generated by it
// Key: entryPath (e.g., 'about')
// Value: Set<string> of virtual component IDs generated by this entry
const entryToVirtualComponents = new Map<string, Set<string>>();

// Cache for the list of entries itself
let entries: Set<string> | null = null;

// --- Helper Functions ---

// Function to invalidate specific caches based on a changed file
function invalidateCacheForFile(filePath: string) {
  const affectedEntries = fileToContentEntries.get(filePath);
  if (affectedEntries) {
    affectedEntries.forEach((entryPath) => {
      // 1. Invalidate Page Cache
      pageCache.delete(entryPath);
      logCache(`Invalidated page cache for entry: ${entryPath}`);

      // 2. Invalidate associated Virtual Components
      const affectedVComps = entryToVirtualComponents.get(entryPath);
      if (affectedVComps) {
        affectedVComps.forEach((vcId) => {
          virtualComponentCache.delete(vcId);
          logCache(`Invalidated virtual component cache for: ${vcId}`);
        });
        entryToVirtualComponents.delete(entryPath); // Clear the association
      }

      // 3. Clean up the reverse dependency map for this entry
      // (Iterate fileToContentEntries and remove this entryPath from sets)
      // This is important if the file dependencies themselves change on reload.
      // Alternatively, rebuild dependencies during load. Let's stick to simple invalidation first.
    });
    // 4. Clear the forward dependency for the changed file
    fileToContentEntries.delete(filePath);
  }
  // Potentially: Check if the file change affects the *list* of entries
  // (e.g., if discoverContentPaths depends on directory contents)
  // If so, invalidate `entries` cache too. entries = null;
}

// Function to get or load a single page's content
async function getOrLoadPage(
  entryPath: string,
  config: Config
): Promise<SourcePageContent> {
  if (pageCache.has(entryPath)) {
    return pageCache.get(entryPath)!.promise;
  }

  const currentSourceFiles = new Set<string>();
  const generatedVirtualComponents = new Set<string>();

  const pagePromise = loadContent(
    entryPath,
    config,
    // Virtual Component Callback
    (processedVirtualComponent) => {
      if (processedVirtualComponent?.component) {
        // Already prefixed e.g., composably:component/MyVirtualComp
        const vcId = processedVirtualComponent.component;
        logCache(`Caching virtual component: ${vcId} from entry: ${entryPath}`);
        virtualComponentCache.set(vcId, {
          data: processedVirtualComponent,
          sourceEntryPath: entryPath
        });
        generatedVirtualComponents.add(vcId);
        // We don't know the *exact* source lines, but we know it came
        // *from processing* this entryPath.
        // Dependencies on source files are handled via reportFileDependency.
      } else {
        console.warn(/* ... warning ... */);
      }
    },
    // File Dependency Callback
    (absolutePath) => {
      let existingEntries = fileToContentEntries.get(absolutePath);
      if (!existingEntries) {
        existingEntries = new Set();
        fileToContentEntries.set(absolutePath, existingEntries);
      }

      // Check if this specific entry is already registered for this file
      if (!existingEntries.has(entryPath)) {
        logCache(
          `Registering dependency: ${entryPath || '/'} -> ${absolutePath}`
        );
        existingEntries.add(entryPath);
        currentSourceFiles.add(absolutePath);
      } else {
        logCache(
          `Skipping duplicate dependency registration: ${entryPath || '/'} -> ${absolutePath}`
        );
      }
    }
  ).catch((err) => {
    // Handle errors during loadContent, remove promise from cache
    pageCache.delete(entryPath);
    // Clear potentially partial dependencies (optional, depends on desired error resilience)
    currentSourceFiles.forEach((f) =>
      fileToContentEntries.get(f)?.delete(entryPath)
    );
    generatedVirtualComponents.forEach((vcId) =>
      virtualComponentCache.delete(vcId)
    );
    entryToVirtualComponents.delete(entryPath);
    console.error(`Error loading content for ${entryPath || '/'}:`, err);
    throw err; // Re-throw to propagate the error
  });

  // Store the promise *immediately* to handle concurrent requests for the same page
  pageCache.set(entryPath, {
    promise: pagePromise,
    sourceFiles: currentSourceFiles
  });

  entryToVirtualComponents.set(entryPath, generatedVirtualComponents); // Store VC associations

  const pageContent = await pagePromise;

  return pageContent;
}

function getEntries(config: Config, refresh = false): Set<string> {
  if (refresh || !entries) {
    entries = new Set(discoverContentPaths(config));
  }
  return entries ?? new Set();
}

export async function composably(config: Config): Promise<Plugin> {
  return {
    name: 'svelte-composably',
    enforce: 'pre',

    // --- Inject user project root in config ---
    configResolved(viteResolvedConfig: ResolvedConfig) {
      config.root = viteResolvedConfig.root;
      logConfig(`Composably Plugin: Project root resolved to ${config.root}`);
      getEntries(config, true);
    },

    resolveId(source: string): string | undefined {
      if (source === VIRTUAL_CONTENT) {
        return RESOLVED_CONTENT;
      }
      if (source.startsWith(VIRTUAL_PAGE)) {
        // Ensure valid entry path before resolving
        const entry = source.slice(VIRTUAL_PAGE.length);
        if (getEntries(config).has(entry)) {
          // Check against current known entries
          return `\0${source}`; // Use original source with null byte
        }
        console.warn(
          `Attempted to resolve non-existent content entry: ${entry}`
        );
        return undefined; // Don't resolve if entry doesn't exist
      }
      if (source.startsWith(VIRTUAL_COMPONENT)) {
        // No null byte needed as it should be treated like a normal svelte
        // file path for Vite/Svelte plugin.
        // Check if it exists in the cache (optional, load will handle it)
        // if (virtualComponentCache.has(source)) { ... }
        return source; // Assuming Vite/Svelte handles .svelte resolution
      }
      return undefined; // Explicitly return undefined for other cases
    },

    async load(id) {
      // --- Load VIRTUAL_CONTENT list ---
      if (id === RESOLVED_CONTENT) {
        logLoad('Loading:', RESOLVED_CONTENT);
        const currentEntries = Array.from(getEntries(config, true));

        // Generate case statements for each entry
        const cases = currentEntries
          .map(
            (p) =>
              `case '${p}': return (await import('${VIRTUAL_PAGE}${p}')).default();`
          )
          .join('\n');

        const errorMessage = `Not in: [${currentEntries.join(',')}]`;

        // Generate the code for the virtual module, exporting a single async function
        const code = `
export default async function loadPageContent(path) {
switch (path) {
${cases}
default: throw new Error(\`${errorMessage}\`);}}`;
        return code;
      }

      // --- Load specific page content ---
      // Match resolved ID: \0composably:content/about
      if (id.startsWith(RESOLVED_PAGE)) {
        const entryPath = id.slice(RESOLVED_PAGE.length);
        logLoad('Loading:', id, `(Entry: ${entryPath || '/'})`);
        try {
          // Use the granular getter/loader
          const page = await getOrLoadPage(entryPath, config);

          // Stringify and replace components
          // Consider caching the result of this expensive operation too,
          // invalidated when the page content or component code changes.
          let code = `export default async () => (${JSON.stringify(page)});`;
          code = code.replace(/"component":"([^"]+)"/g, (_, compPath) => {
            const isVirtual = compPath.startsWith(VIRTUAL_COMPONENT);
            const importPath = isVirtual
              ? `${compPath}.svelte` // Append suffix for virtual Svelte components
              : `/${config.componentRoot}/${compPath}.svelte`; // Path to real component
            return `"component":(await import('${importPath}')).default`;
          });
          return code;
        } catch (error) {
          console.error(`Error processing load for ${id}:`, error);
          return `export default async () => { throw new Error("Failed to load content for ${entryPath || '/'}"); };`;
        }
      }

      // --- Load virtual component code ---
      // Match ID like composably:component/MyVirtualComp.svelte
      // Ensure the ID includes the suffix if resolveId doesn't add \0
      const vcMatch = id.match(
        new RegExp(
          `^${VIRTUAL_COMPONENT.replace(':', '\\:')}(.+)${COMPONENT_SUFFIX}$`
        )
      );
      if (!vcMatch) {
        return null; // Let other plugins handle other IDs
      }
      const vcName = `${VIRTUAL_COMPONENT}${vcMatch[1]}`; // Reconstruct the key used in the cache
      logLoad('Loading Virtual Component:', id, `(Name: ${vcName})`);

      const cachedVC = virtualComponentCache.get(vcName);

      if (!cachedVC) {
        console.warn(
          `Virtual component data not found in cache for: ${vcName}`
        );
        // Attempt to reload the source page? This might be complex.
        // Or rely on HMR invalidation to fix it.
        // For now, return an error/empty component.
        return `<script>console.error("Virtual component ${vcName} not loaded.");</script>`;
      }

      const { data } = cachedVC;
      const { component: _, ...props } = data; // Destructure the SourceComponentContent

      // Including html enable {@html props.html}, which could be useful,
      // If not it should be deleted upstream
      const propKeys = Object.keys(props).filter((k) => k !== 'html');

      const propString = `{ ${propKeys.join(', ')} } = $props();`;
      const scriptString =
        propKeys.length > 0 ? `<script>\nlet ${propString};\n</script>\n` : '';

      return {
        code: `${scriptString}\n${props.html || ''}`,
        map: VIRTUAL_SOURCEMAP
      };
    },

    async handleHotUpdate({ file, server }) {
      logHMR(`HMR triggered by: ${file}`);
      const absolutePath = file; // Assuming 'file' is absolute path

      // Check if the changed file affects any content entry
      const affectedEntries = fileToContentEntries.get(absolutePath);
      const modulesToReload = new Set<import('vite').ModuleNode>();

      if (affectedEntries && affectedEntries.size > 0) {
        logHMR(`File ${absolutePath} affects entries:`, affectedEntries);

        // Invalidate caches for affected entries AND their virtual components
        invalidateCacheForFile(absolutePath); // Use the helper

        // Find the Vite modules to reload
        for (const entryPath of affectedEntries) {
          // 1. Reload the page module (`\0composably:content/entryPath`)
          const pageModuleId = `${RESOLVED_PAGE}${entryPath}`;
          const pageMod = server.moduleGraph.getModuleById(pageModuleId);
          if (pageMod) {
            logHMR(`Invalidating page module: ${pageModuleId}`);
            server.moduleGraph.invalidateModule(pageMod);
            modulesToReload.add(pageMod);
          } else {
            logHMR(
              `Page module not found in graph (may not be loaded yet): ${pageModuleId}`
            );
          }

          // 2. Reload affected virtual component modules
          // We need the VCs associated *before* invalidation, so retrieve before full cleanup
          // (Alternatively, invalidateCacheForFile could return affected VC IDs)
          // Let's assume virtualComponentCache might still hold *stale* data linking back
          // A better way: iterate virtualComponentCache *before* invalidation
          for (const [vcId, vcData] of virtualComponentCache.entries()) {
            // Check cache before full clear
            if (vcData.sourceEntryPath === entryPath) {
              const vcModuleId = `${vcId}.svelte`; // Append suffix
              const vcMod = server.moduleGraph.getModuleById(vcModuleId);
              if (vcMod) {
                logHMR(`Invalidating virtual component module: ${vcModuleId}`);
                server.moduleGraph.invalidateModule(vcMod);
                modulesToReload.add(vcMod);
              } else {
                logHMR(`VC module not found in graph: ${vcModuleId}`);
              }
            }
          }
        }
      } else {
        logHMR(
          `File ${absolutePath} does not directly affect known content entries.`
        );
      }

      if (modulesToReload.size > 0) {
        logHMR(
          'Requesting reload for modules:',
          Array.from(modulesToReload).map((m) => m.id || m.url)
        );
        return Array.from(modulesToReload);
      }

      // If the file didn't affect any of our modules, let Vite handle it normally.
      return undefined; // Explicitly return undefined if we didn't handle it
    },

    // Optional: configureServer hook to perform initial scan
    configureServer(server) {
      logBase(
        'Composably Plugin: configureServer - Performing initial content scan...'
      );
      getEntries(config, true);
      const contentPathPrefix = toAbsolutePath(path.sep, config);

      const handleFileEvent = async (
        filePath: string,
        eventType: 'add' | 'unlink' | 'change'
      ) => {
        // Filter for files within the content directory and with correct extensions
        if (filePath.startsWith(contentPathPrefix)) {
          const fileExtension = path.extname(filePath).substring(1);
          if (
            filetypes.includes(fileExtension) &&
            path.basename(filePath)[0] !== '_'
          ) {
            const mod = server.moduleGraph.getModuleById(RESOLVED_CONTENT);
            if (mod) {
              logHMR(
                `Invalidating ${RESOLVED_CONTENT} due to ${eventType} ${filePath}`
              );
              server.moduleGraph.invalidateModule(mod);
              server.ws.send({
                type: 'update',
                updates: [
                  {
                    type: 'js-update',
                    path: mod.url,
                    acceptedPath: mod.url,
                    timestamp: Date.now()
                  }
                ]
              });
            }
          }
        }
      };

      server.watcher.on('add', (filePath) => handleFileEvent(filePath, 'add'));
      server.watcher.on('unlink', (filePath) =>
        handleFileEvent(filePath, 'unlink')
      );
    }
  };
}
